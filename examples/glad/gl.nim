#[
    OpenGL loader generated by glad 0.1.34 on Thu Dec  3 10:59:14 2020.

    Language/Generator: Nim
    Specification: gl
    APIs: gl=1.0
    Profile: core
    Extensions:

    Loader: True
    Local files: False
    Omit khrplatform: False
    Reproducible: False

    Commandline:
        --profile="core" --api="gl=1.0" --generator="nim" --spec="gl" --extensions=""
    Online:
        https://glad.dav1d.de/#profile=core&language=nim&specification=gl&loader=on&api=gl%3D1.0
]#

import strutils

var glVersionMajor, glVersionMinor: int

# Types
type
  ClContext* = distinct pointer
  ClEvent* = distinct pointer
  GLVULKANPROCNV* = pointer
  GLbitfield* = uint32
  GLboolean* = bool
  GLbyte* = int8
  GLchar* = char
  GLcharARB* = byte
  GLclampd* = float64
  GLclampf* = float32
  GLclampx* = int32
  GLdouble* = float64
  GLeglClientBufferEXT* = pointer
  GLeglImageOES* = distinct pointer
  GLenum* = uint32
  GLfixed* = int32
  GLfloat* = float32
  GLhalf* = uint16
  GLhalfARB* = uint16
  GLhalfNV* = uint16
  GLhandleARB* = uint32
  GLint* = int32
  GLint64* = int64
  GLint64EXT* = int64
  GLintptr* = int
  GLintptrARB* = int
  GLshort* = int16
  GLsizei* = int32
  GLsizeiptr* = int
  GLsizeiptrARB* = int
  GLsync* = distinct pointer
  GLubyte* = uint8
  GLuint* = uint32
  GLuint64* = uint64
  GLuint64EXT* = uint64
  GLushort* = uint16
  GLvdpauSurfaceNV* = int32
  GLvoid* = pointer

  GLdebugProc* = proc (
    source: GLenum,
    typ: GLenum,
    id: GLuint,
    severity: GLenum,
    length: GLsizei,
    message: ptr GLchar,
    userParam: pointer) {.stdcall.}

  GLdebugProcArb* = proc (
    source: GLenum,
    typ: GLenum,
    id: GLuint,
    severity: GLenum,
    len: GLsizei,
    message: ptr GLchar,
    userParam: pointer) {.stdcall.}

  GLdebugProcAmd* = proc (
    id: GLuint,
    category: GLenum,
    severity: GLenum,
    len: GLsizei,
    message: ptr GLchar,
    userParam: pointer) {.stdcall.}

  GLdebugProcKhr* = proc (
    source, typ: GLenum,
    id: GLuint,
    severity: GLenum,
    length: GLsizei,
    message: ptr GLchar,
    userParam: pointer) {.stdcall.}


# Enums
const
  GL_FALSE* = 0
  GL_INVALID_INDEX*: uint32 = uint32(0xFFFFFFFF)
  GL_NONE* = 0
  GL_NONE_OES* = 0
  GL_NO_ERROR* = 0
  GL_ONE* = 1
  GL_TIMEOUT_IGNORED*: uint64 = 0xFFFFFFFFFFFFFFFF'u64
  GL_TIMEOUT_IGNORED_APPLE*: uint64 = 0xFFFFFFFFFFFFFFFF'u64
  GL_TRUE* = 1
  GL_VERSION_ES_CL_1_0* = 1
  GL_VERSION_ES_CL_1_1* = 1
  GL_VERSION_ES_CM_1_1* = 1
  GL_ZERO* = 0

  GL_DEPTH_BUFFER_BIT*: GLenum = GLenum(0x00000100)
  GL_STENCIL_BUFFER_BIT*: GLenum = GLenum(0x00000400)
  GL_COLOR_BUFFER_BIT*: GLenum = GLenum(0x00004000)
  GL_POINTS*: GLenum = GLenum(0x0000)
  GL_LINES*: GLenum = GLenum(0x0001)
  GL_LINE_LOOP*: GLenum = GLenum(0x0002)
  GL_LINE_STRIP*: GLenum = GLenum(0x0003)
  GL_TRIANGLES*: GLenum = GLenum(0x0004)
  GL_TRIANGLE_STRIP*: GLenum = GLenum(0x0005)
  GL_TRIANGLE_FAN*: GLenum = GLenum(0x0006)
  GL_NEVER*: GLenum = GLenum(0x0200)
  GL_LESS*: GLenum = GLenum(0x0201)
  GL_EQUAL*: GLenum = GLenum(0x0202)
  GL_LEQUAL*: GLenum = GLenum(0x0203)
  GL_GREATER*: GLenum = GLenum(0x0204)
  GL_NOTEQUAL*: GLenum = GLenum(0x0205)
  GL_GEQUAL*: GLenum = GLenum(0x0206)
  GL_ALWAYS*: GLenum = GLenum(0x0207)
  GL_SRC_COLOR*: GLenum = GLenum(0x0300)
  GL_ONE_MINUS_SRC_COLOR*: GLenum = GLenum(0x0301)
  GL_SRC_ALPHA*: GLenum = GLenum(0x0302)
  GL_ONE_MINUS_SRC_ALPHA*: GLenum = GLenum(0x0303)
  GL_DST_ALPHA*: GLenum = GLenum(0x0304)
  GL_ONE_MINUS_DST_ALPHA*: GLenum = GLenum(0x0305)
  GL_DST_COLOR*: GLenum = GLenum(0x0306)
  GL_ONE_MINUS_DST_COLOR*: GLenum = GLenum(0x0307)
  GL_SRC_ALPHA_SATURATE*: GLenum = GLenum(0x0308)
  GL_FRONT_LEFT*: GLenum = GLenum(0x0400)
  GL_FRONT_RIGHT*: GLenum = GLenum(0x0401)
  GL_BACK_LEFT*: GLenum = GLenum(0x0402)
  GL_BACK_RIGHT*: GLenum = GLenum(0x0403)
  GL_FRONT*: GLenum = GLenum(0x0404)
  GL_BACK*: GLenum = GLenum(0x0405)
  GL_LEFT*: GLenum = GLenum(0x0406)
  GL_RIGHT*: GLenum = GLenum(0x0407)
  GL_FRONT_AND_BACK*: GLenum = GLenum(0x0408)
  GL_INVALID_ENUM*: GLenum = GLenum(0x0500)
  GL_INVALID_VALUE*: GLenum = GLenum(0x0501)
  GL_INVALID_OPERATION*: GLenum = GLenum(0x0502)
  GL_OUT_OF_MEMORY*: GLenum = GLenum(0x0505)
  GL_CW*: GLenum = GLenum(0x0900)
  GL_CCW*: GLenum = GLenum(0x0901)
  GL_POINT_SIZE*: GLenum = GLenum(0x0B11)
  GL_POINT_SIZE_RANGE*: GLenum = GLenum(0x0B12)
  GL_POINT_SIZE_GRANULARITY*: GLenum = GLenum(0x0B13)
  GL_LINE_SMOOTH*: GLenum = GLenum(0x0B20)
  GL_LINE_WIDTH*: GLenum = GLenum(0x0B21)
  GL_LINE_WIDTH_RANGE*: GLenum = GLenum(0x0B22)
  GL_LINE_WIDTH_GRANULARITY*: GLenum = GLenum(0x0B23)
  GL_POLYGON_MODE*: GLenum = GLenum(0x0B40)
  GL_POLYGON_SMOOTH*: GLenum = GLenum(0x0B41)
  GL_CULL_FACE*: GLenum = GLenum(0x0B44)
  GL_CULL_FACE_MODE*: GLenum = GLenum(0x0B45)
  GL_FRONT_FACE*: GLenum = GLenum(0x0B46)
  GL_DEPTH_RANGE*: GLenum = GLenum(0x0B70)
  GL_DEPTH_TEST*: GLenum = GLenum(0x0B71)
  GL_DEPTH_WRITEMASK*: GLenum = GLenum(0x0B72)
  GL_DEPTH_CLEAR_VALUE*: GLenum = GLenum(0x0B73)
  GL_DEPTH_FUNC*: GLenum = GLenum(0x0B74)
  GL_STENCIL_TEST*: GLenum = GLenum(0x0B90)
  GL_STENCIL_CLEAR_VALUE*: GLenum = GLenum(0x0B91)
  GL_STENCIL_FUNC*: GLenum = GLenum(0x0B92)
  GL_STENCIL_VALUE_MASK*: GLenum = GLenum(0x0B93)
  GL_STENCIL_FAIL*: GLenum = GLenum(0x0B94)
  GL_STENCIL_PASS_DEPTH_FAIL*: GLenum = GLenum(0x0B95)
  GL_STENCIL_PASS_DEPTH_PASS*: GLenum = GLenum(0x0B96)
  GL_STENCIL_REF*: GLenum = GLenum(0x0B97)
  GL_STENCIL_WRITEMASK*: GLenum = GLenum(0x0B98)
  GL_VIEWPORT*: GLenum = GLenum(0x0BA2)
  GL_DITHER*: GLenum = GLenum(0x0BD0)
  GL_BLEND_DST*: GLenum = GLenum(0x0BE0)
  GL_BLEND_SRC*: GLenum = GLenum(0x0BE1)
  GL_BLEND*: GLenum = GLenum(0x0BE2)
  GL_LOGIC_OP_MODE*: GLenum = GLenum(0x0BF0)
  GL_DRAW_BUFFER*: GLenum = GLenum(0x0C01)
  GL_READ_BUFFER*: GLenum = GLenum(0x0C02)
  GL_SCISSOR_BOX*: GLenum = GLenum(0x0C10)
  GL_SCISSOR_TEST*: GLenum = GLenum(0x0C11)
  GL_COLOR_CLEAR_VALUE*: GLenum = GLenum(0x0C22)
  GL_COLOR_WRITEMASK*: GLenum = GLenum(0x0C23)
  GL_DOUBLEBUFFER*: GLenum = GLenum(0x0C32)
  GL_STEREO*: GLenum = GLenum(0x0C33)
  GL_LINE_SMOOTH_HINT*: GLenum = GLenum(0x0C52)
  GL_POLYGON_SMOOTH_HINT*: GLenum = GLenum(0x0C53)
  GL_UNPACK_SWAP_BYTES*: GLenum = GLenum(0x0CF0)
  GL_UNPACK_LSB_FIRST*: GLenum = GLenum(0x0CF1)
  GL_UNPACK_ROW_LENGTH*: GLenum = GLenum(0x0CF2)
  GL_UNPACK_SKIP_ROWS*: GLenum = GLenum(0x0CF3)
  GL_UNPACK_SKIP_PIXELS*: GLenum = GLenum(0x0CF4)
  GL_UNPACK_ALIGNMENT*: GLenum = GLenum(0x0CF5)
  GL_PACK_SWAP_BYTES*: GLenum = GLenum(0x0D00)
  GL_PACK_LSB_FIRST*: GLenum = GLenum(0x0D01)
  GL_PACK_ROW_LENGTH*: GLenum = GLenum(0x0D02)
  GL_PACK_SKIP_ROWS*: GLenum = GLenum(0x0D03)
  GL_PACK_SKIP_PIXELS*: GLenum = GLenum(0x0D04)
  GL_PACK_ALIGNMENT*: GLenum = GLenum(0x0D05)
  GL_MAX_TEXTURE_SIZE*: GLenum = GLenum(0x0D33)
  GL_MAX_VIEWPORT_DIMS*: GLenum = GLenum(0x0D3A)
  GL_SUBPIXEL_BITS*: GLenum = GLenum(0x0D50)
  GL_TEXTURE_1D*: GLenum = GLenum(0x0DE0)
  GL_TEXTURE_2D*: GLenum = GLenum(0x0DE1)
  GL_TEXTURE_WIDTH*: GLenum = GLenum(0x1000)
  GL_TEXTURE_HEIGHT*: GLenum = GLenum(0x1001)
  GL_TEXTURE_BORDER_COLOR*: GLenum = GLenum(0x1004)
  GL_DONT_CARE*: GLenum = GLenum(0x1100)
  GL_FASTEST*: GLenum = GLenum(0x1101)
  GL_NICEST*: GLenum = GLenum(0x1102)
  cGL_BYTE*: GLenum = GLenum(0x1400)
  GL_UNSIGNED_BYTE*: GLenum = GLenum(0x1401)
  cGL_SHORT*: GLenum = GLenum(0x1402)
  GL_UNSIGNED_SHORT*: GLenum = GLenum(0x1403)
  cGL_INT*: GLenum = GLenum(0x1404)
  GL_UNSIGNED_INT*: GLenum = GLenum(0x1405)
  cGL_FLOAT*: GLenum = GLenum(0x1406)
  GL_CLEAR*: GLenum = GLenum(0x1500)
  GL_AND*: GLenum = GLenum(0x1501)
  GL_AND_REVERSE*: GLenum = GLenum(0x1502)
  GL_COPY*: GLenum = GLenum(0x1503)
  GL_AND_INVERTED*: GLenum = GLenum(0x1504)
  GL_NOOP*: GLenum = GLenum(0x1505)
  GL_XOR*: GLenum = GLenum(0x1506)
  GL_OR*: GLenum = GLenum(0x1507)
  GL_NOR*: GLenum = GLenum(0x1508)
  GL_EQUIV*: GLenum = GLenum(0x1509)
  GL_INVERT*: GLenum = GLenum(0x150A)
  GL_OR_REVERSE*: GLenum = GLenum(0x150B)
  GL_COPY_INVERTED*: GLenum = GLenum(0x150C)
  GL_OR_INVERTED*: GLenum = GLenum(0x150D)
  GL_NAND*: GLenum = GLenum(0x150E)
  GL_SET*: GLenum = GLenum(0x150F)
  GL_TEXTURE*: GLenum = GLenum(0x1702)
  GL_COLOR*: GLenum = GLenum(0x1800)
  GL_DEPTH*: GLenum = GLenum(0x1801)
  GL_STENCIL*: GLenum = GLenum(0x1802)
  GL_STENCIL_INDEX*: GLenum = GLenum(0x1901)
  GL_DEPTH_COMPONENT*: GLenum = GLenum(0x1902)
  GL_RED*: GLenum = GLenum(0x1903)
  GL_GREEN*: GLenum = GLenum(0x1904)
  GL_BLUE*: GLenum = GLenum(0x1905)
  GL_ALPHA*: GLenum = GLenum(0x1906)
  GL_RGB*: GLenum = GLenum(0x1907)
  GL_RGBA*: GLenum = GLenum(0x1908)
  GL_POINT*: GLenum = GLenum(0x1B00)
  GL_LINE*: GLenum = GLenum(0x1B01)
  GL_FILL*: GLenum = GLenum(0x1B02)
  GL_KEEP*: GLenum = GLenum(0x1E00)
  GL_REPLACE*: GLenum = GLenum(0x1E01)
  GL_INCR*: GLenum = GLenum(0x1E02)
  GL_DECR*: GLenum = GLenum(0x1E03)
  GL_VENDOR*: GLenum = GLenum(0x1F00)
  GL_RENDERER*: GLenum = GLenum(0x1F01)
  GL_VERSION*: GLenum = GLenum(0x1F02)
  GL_EXTENSIONS*: GLenum = GLenum(0x1F03)
  GL_NEAREST*: GLenum = GLenum(0x2600)
  GL_LINEAR*: GLenum = GLenum(0x2601)
  GL_NEAREST_MIPMAP_NEAREST*: GLenum = GLenum(0x2700)
  GL_LINEAR_MIPMAP_NEAREST*: GLenum = GLenum(0x2701)
  GL_NEAREST_MIPMAP_LINEAR*: GLenum = GLenum(0x2702)
  GL_LINEAR_MIPMAP_LINEAR*: GLenum = GLenum(0x2703)
  GL_TEXTURE_MAG_FILTER*: GLenum = GLenum(0x2800)
  GL_TEXTURE_MIN_FILTER*: GLenum = GLenum(0x2801)
  GL_TEXTURE_WRAP_S*: GLenum = GLenum(0x2802)
  GL_TEXTURE_WRAP_T*: GLenum = GLenum(0x2803)
  GL_REPEAT*: GLenum = GLenum(0x2901)


# Functions
var
  GLAD_GL_VERSION_1_0*: bool

  glCullFace*: proc (mode: GLenum) {.cdecl, gcsafe.}
  glFrontFace*: proc (mode: GLenum) {.cdecl, gcsafe.}
  glHint*: proc (target: GLenum, mode: GLenum) {.cdecl, gcsafe.}
  glLineWidth*: proc (width: GLfloat) {.cdecl, gcsafe.}
  glPointSize*: proc (size: GLfloat) {.cdecl, gcsafe.}
  glPolygonMode*: proc (face: GLenum, mode: GLenum) {.cdecl, gcsafe.}
  glScissor*: proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei) {.cdecl, gcsafe.}
  glTexParameterf*: proc (target: GLenum, pname: GLenum, param: GLfloat) {.cdecl, gcsafe.}
  glTexParameterfv*: proc (target: GLenum, pname: GLenum, params: ptr GLfloat) {.cdecl, gcsafe.}
  glTexParameteri*: proc (target: GLenum, pname: GLenum, param: GLint) {.cdecl, gcsafe.}
  glTexParameteriv*: proc (target: GLenum, pname: GLenum, params: ptr GLint) {.cdecl, gcsafe.}
  glTexImage1D*: proc (target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer) {.cdecl, gcsafe.}
  glTexImage2D*: proc (target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer) {.cdecl, gcsafe.}
  glDrawBuffer*: proc (buf: GLenum) {.cdecl, gcsafe.}
  glClear*: proc (mask: GLbitfield) {.cdecl, gcsafe.}
  glClearColor*: proc (red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) {.cdecl, gcsafe.}
  glClearStencil*: proc (s: GLint) {.cdecl, gcsafe.}
  glClearDepth*: proc (depth: GLdouble) {.cdecl, gcsafe.}
  glStencilMask*: proc (mask: GLuint) {.cdecl, gcsafe.}
  glColorMask*: proc (red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) {.cdecl, gcsafe.}
  glDepthMask*: proc (flag: GLboolean) {.cdecl, gcsafe.}
  glDisable*: proc (cap: GLenum) {.cdecl, gcsafe.}
  glEnable*: proc (cap: GLenum) {.cdecl, gcsafe.}
  glFinish*: proc () {.cdecl, gcsafe.}
  glFlush*: proc () {.cdecl, gcsafe.}
  glBlendFunc*: proc (sfactor: GLenum, dfactor: GLenum) {.cdecl, gcsafe.}
  glLogicOp*: proc (opcode: GLenum) {.cdecl, gcsafe.}
  glStencilFunc*: proc (`func`: GLenum, `ref`: GLint, mask: GLuint) {.cdecl, gcsafe.}
  glStencilOp*: proc (fail: GLenum, zfail: GLenum, zpass: GLenum) {.cdecl, gcsafe.}
  glDepthFunc*: proc (`func`: GLenum) {.cdecl, gcsafe.}
  glPixelStoref*: proc (pname: GLenum, param: GLfloat) {.cdecl, gcsafe.}
  glPixelStorei*: proc (pname: GLenum, param: GLint) {.cdecl, gcsafe.}
  glReadBuffer*: proc (src: GLenum) {.cdecl, gcsafe.}
  glReadPixels*: proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer) {.cdecl, gcsafe.}
  glGetBooleanv*: proc (pname: GLenum, data: ptr GLboolean) {.cdecl, gcsafe.}
  glGetDoublev*: proc (pname: GLenum, data: ptr GLdouble) {.cdecl, gcsafe.}
  glGetError*: proc (): GLenum {.cdecl, gcsafe.}
  glGetFloatv*: proc (pname: GLenum, data: ptr GLfloat) {.cdecl, gcsafe.}
  glGetIntegerv*: proc (pname: GLenum, data: ptr GLint) {.cdecl, gcsafe.}
  glGetString*: proc (name: GLenum): ptr GLubyte {.cdecl, gcsafe.}
  glGetTexImage*: proc (target: GLenum, level: GLint, format: GLenum, `type`: GLenum, pixels: pointer) {.cdecl, gcsafe.}
  glGetTexParameterfv*: proc (target: GLenum, pname: GLenum, params: ptr GLfloat) {.cdecl, gcsafe.}
  glGetTexParameteriv*: proc (target: GLenum, pname: GLenum, params: ptr GLint) {.cdecl, gcsafe.}
  glGetTexLevelParameterfv*: proc (target: GLenum, level: GLint, pname: GLenum, params: ptr GLfloat) {.cdecl, gcsafe.}
  glGetTexLevelParameteriv*: proc (target: GLenum, level: GLint, pname: GLenum, params: ptr GLint) {.cdecl, gcsafe.}
  glIsEnabled*: proc (cap: GLenum): GLboolean {.cdecl, gcsafe.}
  glDepthRange*: proc (n: GLdouble, f: GLdouble) {.cdecl, gcsafe.}
  glViewport*: proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei) {.cdecl, gcsafe.}


# Extensions


proc load_GL_VERSION_1_0(load: proc) =
  if not GLAD_GL_VERSION_1_0: return

  glCullFace = cast[proc (mode: GLenum) {.cdecl, gcsafe.}](load("glCullFace"))
  glFrontFace = cast[proc (mode: GLenum) {.cdecl, gcsafe.}](load("glFrontFace"))
  glHint = cast[proc (target: GLenum, mode: GLenum) {.cdecl, gcsafe.}](load("glHint"))
  glLineWidth = cast[proc (width: GLfloat) {.cdecl, gcsafe.}](load("glLineWidth"))
  glPointSize = cast[proc (size: GLfloat) {.cdecl, gcsafe.}](load("glPointSize"))
  glPolygonMode = cast[proc (face: GLenum, mode: GLenum) {.cdecl, gcsafe.}](load("glPolygonMode"))
  glScissor = cast[proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei) {.cdecl, gcsafe.}](load("glScissor"))
  glTexParameterf = cast[proc (target: GLenum, pname: GLenum, param: GLfloat) {.cdecl, gcsafe.}](load("glTexParameterf"))
  glTexParameterfv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLfloat) {.cdecl, gcsafe.}](load("glTexParameterfv"))
  glTexParameteri = cast[proc (target: GLenum, pname: GLenum, param: GLint) {.cdecl, gcsafe.}](load("glTexParameteri"))
  glTexParameteriv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLint) {.cdecl, gcsafe.}](load("glTexParameteriv"))
  glTexImage1D = cast[proc (target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer) {.cdecl, gcsafe.}](load("glTexImage1D"))
  glTexImage2D = cast[proc (target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, `type`: GLenum, pixels: pointer) {.cdecl, gcsafe.}](load("glTexImage2D"))
  glDrawBuffer = cast[proc (buf: GLenum) {.cdecl, gcsafe.}](load("glDrawBuffer"))
  glClear = cast[proc (mask: GLbitfield) {.cdecl, gcsafe.}](load("glClear"))
  glClearColor = cast[proc (red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat) {.cdecl, gcsafe.}](load("glClearColor"))
  glClearStencil = cast[proc (s: GLint) {.cdecl, gcsafe.}](load("glClearStencil"))
  glClearDepth = cast[proc (depth: GLdouble) {.cdecl, gcsafe.}](load("glClearDepth"))
  glStencilMask = cast[proc (mask: GLuint) {.cdecl, gcsafe.}](load("glStencilMask"))
  glColorMask = cast[proc (red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean) {.cdecl, gcsafe.}](load("glColorMask"))
  glDepthMask = cast[proc (flag: GLboolean) {.cdecl, gcsafe.}](load("glDepthMask"))
  glDisable = cast[proc (cap: GLenum) {.cdecl, gcsafe.}](load("glDisable"))
  glEnable = cast[proc (cap: GLenum) {.cdecl, gcsafe.}](load("glEnable"))
  glFinish = cast[proc () {.cdecl, gcsafe.}](load("glFinish"))
  glFlush = cast[proc () {.cdecl, gcsafe.}](load("glFlush"))
  glBlendFunc = cast[proc (sfactor: GLenum, dfactor: GLenum) {.cdecl, gcsafe.}](load("glBlendFunc"))
  glLogicOp = cast[proc (opcode: GLenum) {.cdecl, gcsafe.}](load("glLogicOp"))
  glStencilFunc = cast[proc (`func`: GLenum, `ref`: GLint, mask: GLuint) {.cdecl, gcsafe.}](load("glStencilFunc"))
  glStencilOp = cast[proc (fail: GLenum, zfail: GLenum, zpass: GLenum) {.cdecl, gcsafe.}](load("glStencilOp"))
  glDepthFunc = cast[proc (`func`: GLenum) {.cdecl, gcsafe.}](load("glDepthFunc"))
  glPixelStoref = cast[proc (pname: GLenum, param: GLfloat) {.cdecl, gcsafe.}](load("glPixelStoref"))
  glPixelStorei = cast[proc (pname: GLenum, param: GLint) {.cdecl, gcsafe.}](load("glPixelStorei"))
  glReadBuffer = cast[proc (src: GLenum) {.cdecl, gcsafe.}](load("glReadBuffer"))
  glReadPixels = cast[proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, `type`: GLenum, pixels: pointer) {.cdecl, gcsafe.}](load("glReadPixels"))
  glGetBooleanv = cast[proc (pname: GLenum, data: ptr GLboolean) {.cdecl, gcsafe.}](load("glGetBooleanv"))
  glGetDoublev = cast[proc (pname: GLenum, data: ptr GLdouble) {.cdecl, gcsafe.}](load("glGetDoublev"))
  glGetError = cast[proc (): GLenum {.cdecl, gcsafe.}](load("glGetError"))
  glGetFloatv = cast[proc (pname: GLenum, data: ptr GLfloat) {.cdecl, gcsafe.}](load("glGetFloatv"))
  glGetIntegerv = cast[proc (pname: GLenum, data: ptr GLint) {.cdecl, gcsafe.}](load("glGetIntegerv"))
  glGetString = cast[proc (name: GLenum): ptr GLubyte {.cdecl, gcsafe.}](load("glGetString"))
  glGetTexImage = cast[proc (target: GLenum, level: GLint, format: GLenum, `type`: GLenum, pixels: pointer) {.cdecl, gcsafe.}](load("glGetTexImage"))
  glGetTexParameterfv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLfloat) {.cdecl, gcsafe.}](load("glGetTexParameterfv"))
  glGetTexParameteriv = cast[proc (target: GLenum, pname: GLenum, params: ptr GLint) {.cdecl, gcsafe.}](load("glGetTexParameteriv"))
  glGetTexLevelParameterfv = cast[proc (target: GLenum, level: GLint, pname: GLenum, params: ptr GLfloat) {.cdecl, gcsafe.}](load("glGetTexLevelParameterfv"))
  glGetTexLevelParameteriv = cast[proc (target: GLenum, level: GLint, pname: GLenum, params: ptr GLint) {.cdecl, gcsafe.}](load("glGetTexLevelParameteriv"))
  glIsEnabled = cast[proc (cap: GLenum): GLboolean {.cdecl, gcsafe.}](load("glIsEnabled"))
  glDepthRange = cast[proc (n: GLdouble, f: GLdouble) {.cdecl, gcsafe.}](load("glDepthRange"))
  glViewport = cast[proc (x: GLint, y: GLint, width: GLsizei, height: GLsizei) {.cdecl, gcsafe.}](load("glViewport"))


proc findExtensionsGL() =
  discard


proc findCoreGL(glVersion: string) =
  # Thank you @elmindreda
  # https://github.com/elmindreda/greg/blob/master/templates/greg.c.in#L176
  # https://github.com/glfw/glfw/blob/master/src/context.c#L36
  var prefixes = ["OpenGL ES-CM ", "OpenGL ES-CL ", "OpenGL ES "]

  var version = glVersion
  for p in prefixes:
    if version.startsWith(p):
      version = version.replace(p)
      break

  var major = ord(glVersion[0]) - ord('0')
  var minor = ord(glVersion[2]) - ord('0')

  glVersionMajor = major
  glVersionMinor = minor

  GLAD_GL_VERSION_1_0 = (major == 1 and minor >= 0) or major > 1


proc gladLoadGL*(load: proc): bool =
  glGetString = cast[proc (name: GLenum): ptr GLubyte {.cdecl, gcsafe.}](load("glGetString"))
  if glGetString == nil: return false

  var glVersion = cast[cstring](glGetString(GL_VERSION))
  if glVersion == nil: return false

  findCoreGL($glVersion)

  load_GL_VERSION_1_0(load)

  findExtensionsGL()


  return glVersionMajor != 0 or glVersionMinor != 0

